---
layout: post
Title: Get Your Trading Strategy Using Python
Subtitle:
---

Hello everyone, welcome back to our blog! 
Last time, we share how to start the very first step of NLP trading strategy development - Collecting the data. In this blog, we would like to introduce how to **test trading strategies** with Python tool. We will take our data collected from the last post as an illustrative example.

## Catch the mood, and… short it

In quantitative trading, investment managers design strategies to buy (take a long position) or borrow and sell (take a short position) automatedly when there is the designated trading signal, i.e. a parameter meets a certain threshold. The position will be closed every day. The best strategy, of course, will be the one who generates the most profit. 
The measurement for its profitability is to calculate the daily **profit and loss**, aka pnl, generated by the strategy. There are two steps of testing, first called **backtest** and the second called **walk forward test**. Backtest is to find the optimal parameters as the trading signal for the trading strategy, and the walk-forward-test will test its performance with more recent data to validate its out-of-sample profitability. If a strategy can achieve a good Sharpe ratio in both tests (larger than 1 favorably), the strategy is deemed as good.

![illustration](https://github.com/thealphaedge/thealphaedge.github.io/blob/master/_posts/calculation%20illustration.jpeg)  

_Illustration for how to calculate daily pnl_  
_P_ stands for the closing price every day. _TC_ stands for the unit transaction cost. 

In our project, we try to speculate the bitcoin futures prices changed based on the analysis of bitcoin-related tweets. The tweets about the bitcoin imply the market expectation of bitcoin. If there is a promising and cheerful mood, more people will buy bitcoin, thus driving up the future contracts price. On the contrary, if there is a negative, pessimistic mood, people will sell bitcoin and the futures price will fall. We wanted to design a trading strategy with the signal of tweets sentiment score. In another word, there is only one parameter in our model: the sentiment score. We will do a backtest to find the optimal sentiment score threshold to decide our position.

![web_image](https://i1.wp.com/ofallthefilmsites.com/wp-content/uploads/2016/07/The-Wolf-of-Wall-Street.jpg)

## Now let’s look at an example

After we downloaded bitcoin tweets from the [last post](https://thealphaedge.github.io/2019-11-27-Getting-Started-With-NLP/), we use [XXX package](link) to generate a sentiment score for each tweet. As the main topic of this post is trading strategy testing, we will not talk in detail about sentimental analysis. Then we merged the sentimental scores into a daily time series data frame and merge it with bitcoin futures contract daily close price.


| Date       | Close price | Score (sum) | Score (avg) |
|------------|-------------|-------------|-------------|
| 12/15/2017 | 19700       | #N/A        | #N/A        |
| 12/18/2017 | 19270       | 0.445       | 0.0371      |
| 12/19/2017 | 18415       | 0.8111      | 0.0386      |
| 12/20/2017 | 17300       | 2.803       | 0.1078      |
| 12/21/2017 | 15595       | #N/A        | #N/A        |
| 12/22/2017 | 14415       | 0.4429      | 0.0148      |
| 12/26/2017 | 16035       | 2.1684      | 0.1668      |
| 12/27/2017 | 14940       | 1.4404      | 0.1309      |
| 12/28/2017 | 13970       | 2.6372      | 0.1758      |
| 12/29/2017 | 14535       | 3.8037      | 0.1153      |
  
_Extract from the merged data frame._

**Step by step process to test with the time series data:**

1. You may notice there are some #N/A in the daily time frame, so firstly forward fill the sentiment score data if it is missed.
2. Calculate the daily return of bitcoin futures as the position holding period is one day if there is any signal
3. Apply the logic into the historical data: if sentiment score is > a threshold, say, 0.6, we will take a long position; if sent score <-0.6, we will take a short position; if sentiment score is within -0.6 and 0.6, we will a zero position
4. After incorporating transaction costs, including commissions, bid-ask spread (negligible), and slippage (negligible), we can obtain adjusted pnl time series for different parameters
 * In this step, we set up a _for loop_ with _bound_ and _step_, calculate the pnl for every parameter in the range
5. The adj pnl is separated into a training set and test set, and we calculate Sharpe ratios respectively in these two sets of data
 * List the top 5 parameters which generated the largest Sharpe ratios in training data set, with their Sharpe ratios in both training and test set

We can look into some codes now.

Import packages needed and basic setups.

```python
# Import packages needed
import pandas as pd
import numpy as np
import datetime as dt
import statsmodels.api as sm
from math import sqrt
from scipy import stats
import os

#input the variableto backtest (sum: bound = 12, step = 0.1; avg: bound = 0.6, step = 0.01)
## add plot for historical data step 5% of total range

score = 'score (avg)'
bound = 0.6
step = 0.01

#dataframe and other variables setup

df = pd.read_excel('YOUR_CSV', index_col = 0, parse_dates = True)
df = df.fillna(method = 'ffill').dropna()   # forward fill N/A fields
df['p_%chg'] = df['close'].pct_change()  # percentage change of daily close price
res = []  # create an empty list for result

#input transaction costs 
tc = 10/(8500*5)   # transaction cost per contract of CME bitcoin futures
```

Parameter optimization: find the threshold with the highest Sharpe ratios.

```python
#optimizer
for i in np.arange(0, bound, step):
    try:
        df['posi'] = np.where(df[score]>i, 1, np.where(df[score]<-i, -1, 0))
        df['pnl'] = df['posi'].shift(1) * df['p_%chg'] - abs(df['posi'].diff()) * tc
        sr_is = df['pnl'].iloc[:123].mean() / df['pnl'].iloc[:123].std() * sqrt(252)   # calculate in-sample Sharpe ratio
        sr_os = df['pnl'].iloc[123:].mean() / df['pnl'].iloc[123:].std() * sqrt(252)  # calculate out-sample Sharpe ratio
## The easiest way to divide training and test set is seperate the data with a 8:2 in-sample to out-sample rate, however there are also other more advanced way to divide data set
        res.append([sr_is, sr_os, i])   
        
    except:
        res.append(['math error', 'math error', i]) # Define math error which will occur when the standard deriviation is 0

# Wrirte the result in dataframe and print out the data with best Sharpe ratios       
opt = pd.DataFrame(res)
opt.columns = ['sr_is', 'sr_os', 'thres']
opt = opt[opt['sr_is'] != 'math error'].sort_values(by = 'sr_is', ascending = False)
print(opt.head())        
```

![output](https://github.com/thealphaedge/thealphaedge.github.io/blob/master/_posts/output.png)  
_Example of output_

In this example, the backtesting part works okay however none of the parameter passes the walk-forward-test (the out-sample Sharpe ratio is too low or even negative).

The robustness of the strat can also be checked by plotting the pnl curves.

```python

#optimized result plotting 
thres = opt['thres'].iloc[0]
df['posi'] = np.where(df[score]>thres, 1, np.where(df[score]<-thres, -1, 0))
df['pnl'] = df['posi'].shift(1) * df['p_%chg'] - abs(df['posi'].diff()) * tc
df['cpnl'] = df['pnl'].cumsum()   ## arithmetic sum, assumption: no reinvestment
df['cpnl'].plot()
```

![plot](https://github.com/thealphaedge/thealphaedge.github.io/blob/master/_posts/plot.png)   
_Example of pnl plot_    


## Wish you a nice day!
Thank you for reading this post! Hope this post helps you to understand how to carry out backtest and optimize your trading strategy using python! Hope you have fun in your own project and may we meet again in the future! 

![thanks](https://i.ebayimg.com/images/g/W78AAOSwWhlc7zmv/s-l1600.png)
